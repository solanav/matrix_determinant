;**************************************************************************
; SBM 2019. ESTRUCTURA BÁSICA DE UN PROGRAMA EN ENSAMBLADOR
;
; PAREJA 14
;**************************************************************************
; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
ORDEN		EQU 3
NUMDATOS	EQU 9
LEFT_OFFSET	EQU 9
CELL_SIZE	EQU 4

MATRIZGUARD	DB 0, 1, 2, 3, 4, 5, 6, 7, 8
TOP		DB "      |   |   |   |", 10, 13, '$'
MID		DB "|A| = |   |   |   | =    ", 10, 13, '$'
BOT		DB "      |   |   |   |", 10, 13, '$'
DIS_NUMBER	DB 0
TMP_INPUT	DB 4, "000"
DATOS ENDS

;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS

;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
RESULT DW 0,0 ;ejemplo de inicialización. 2 PALABRAS (4 BYTES)
EXTRA ENDS

;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
MOV AX, DATOS
MOV DS, AX
MOV AX, PILA
MOV SS, AX
MOV AX, EXTRA
MOV ES, AX
MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
; FIN DE LAS INICIALIZACIONES

;**************************************************************************
; COMIENZO DEL PROGRAMA
; GET USER INPUT
GET_NUMBER:
MOV AH, 0AH
MOV DX, OFFSET TMP_INPUT
INT 21H
MOV AH, 0
MOV SI, 2
MOV AL, TMP_INPUT[SI]
CMP TMP_INPUT, 48
JG FINISH_INPUT
MOV SI, 3
CMP TMP_INPUT[SI], 49
JG FINISH_INPUT
MOV SI, 4
CMP TMP_INPUT[SI], 54
JG FINISH_INPUT
FINISH_INPUT:
JMP END_END
; LOAD MATRIX INTO MEMORY
XOR CX, CX ; VERTICAL ITERATOR
LOAD_MATRIX:
XOR SI, SI ; HORIZONTAL ITERATOR
LOAD_LINE:
PUSH SI ; AL = MATRIZGUARD[SI + CX * 3]
MOV AX, 3
MUL CX
ADD SI, AX
MOV AL, MATRIZGUARD[SI]
POP SI

PUSH SI
PUSH AX

MOV AX, SI ; LOAD SI * 4 INTO SI
MOV BX, CELL_SIZE
MUL BX
MOV SI, AX

ADD SI, LEFT_OFFSET
POP AX ; GET NEXT NUMBER BACK
ADD AX, 48 ; NUMBER TO ASCII

CMP CX, 1 ; CHECK WHAT LINE TO PRINT
JE MID_LINE
JG BOT_LINE

TOP_LINE:
MOV TOP[SI], AL ; TODO: REPLACE WITH BETTER FUNTION
		; THIS ONE ONLY MOVES THE GIVEN BYTE AS ASCII
JMP CONT_LINE
MID_LINE:
MOV MID[SI], AL
JMP CONT_LINE
BOT_LINE:
MOV BOT[SI], AL
JMP CONT_LINE

CONT_LINE:
POP SI ; HORIZONTAL CHECK
INC SI
CMP SI, ORDEN
JNE LOAD_LINE

INC CX ; VERTICAL CHECK
CMP CX, ORDEN
JNE LOAD_MATRIX

; PRINT FUNCTION
PRINT_MATRIX:
MOV DX, OFFSET TOP
MOV AH, 9H
INT 21H

MOV DX, OFFSET MID
MOV AH, 9H
INT 21H

MOV DX, OFFSET BOT
MOV AH, 9H
INT 21H
JMP END_END

; NUM DIS
NUM_DIS:
MOV DX, 0 ; FIRST NUM
MOV AH, 0
MOV AL, DIS_NUMBER
MOV CX, 100
DIV CX
PUSH AX ; SAVE FIRST NUMBER

MUL CX
MOV CX, AX
MOV AX, WORD PTR DIS_NUMBER
SUB AX, CX
MOV CX, 10
DIV CX
PUSH AX ; SAVE SECOND NUMBER

MUL CX
MOV AX, WORD PTR DIS_NUMBER
MOV SI, SP
MOV BX, SS:[SI + 2]

MOV AX, 100
MUL BX
MOV CX, WORD PTR DIS_NUMBER
SUB CX, AX

MOV SI, SP
MOV BX, SS:[SI]
MOV AX, 10
MUL BX
SUB CX, AX
PUSH CX ; SAVE THIRD NUMBER

; FIN DEL PROGRAMA
;**************************************************************************
END_END:
MOV AX, 4C00H
INT 21H
INICIO ENDP
; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO
